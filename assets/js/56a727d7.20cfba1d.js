/*! For license information please see 56a727d7.20cfba1d.js.LICENSE.txt */
"use strict";(self.webpackChunkreact_native_website=self.webpackChunkreact_native_website||[]).push([[95108],{47772:(e,n,t)=>{t.d(n,{ZP:()=>r});var a=t(24246),i=t(71670);function o(e){const n=Object.assign({admonition:"admonition",p:"p",strong:"strong",a:"a"},(0,i.ah)(),e.components);return(0,a.jsxs)(n.admonition,{type:"caution",children:[(0,a.jsxs)(n.p,{children:["This documentation is still ",(0,a.jsx)(n.strong,{children:"experimental"})," and details are subject to changes as we iterate. Feel free to share your feedback on the ",(0,a.jsx)(n.a,{href:"https://github.com/reactwg/react-native-new-architecture/discussions/8",children:"discussion inside the working group"})," for this page."]}),(0,a.jsxs)(n.p,{children:["Moreover, it contains several ",(0,a.jsx)(n.strong,{children:"manual steps"}),". Please note that this won't be representative of the final developer experience once the New Architecture is stable. We're working on tools, templates and libraries to help you get started fast on the New Architecture, without having to go through the whole setup."]})]})}const r=function(e={}){const{wrapper:n}=Object.assign({},(0,i.ah)(),e.components);return n?(0,a.jsx)(n,Object.assign({},e,{children:(0,a.jsx)(o,e)})):o(e)}},99046:(e,n,t)=>{t.d(n,{ZP:()=>r});var a=t(24246),i=t(71670);function o(e){const n=Object.assign({admonition:"admonition",p:"p"},(0,i.ah)(),e.components);return(0,a.jsx)(n.admonition,{type:"caution",children:(0,a.jsx)(n.p,{children:"The TypeScript support for the New Architecture is still in beta."})})}const r=function(e={}){const{wrapper:n}=Object.assign({},(0,i.ah)(),e.components);return n?(0,a.jsx)(n,Object.assign({},e,{children:(0,a.jsx)(o,e)})):o(e)}},2679:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>u,contentTitle:()=>p,default:()=>b,frontMatter:()=>d,metadata:()=>h,toc:()=>m});var a=t(24246),i=t(71670),o=t(48375),r=t(86386),s=t(11674),c=t(99046),l=t(47772);const d={id:"backward-compatibility-fabric-components",title:"Fabric Components as Legacy Native Components"},p=void 0,h={id:"the-new-architecture/backward-compatibility-fabric-components",title:"Fabric Components as Legacy Native Components",description:"Creating a backward compatible Fabric Native Component requires the knowledge of how to create a Legacy Native Component. To recall these concepts, have a look at this guide.",source:"@site/versioned_docs/version-0.70/the-new-architecture/backward-compatibility-fabric-components.md",sourceDirName:"the-new-architecture",slug:"/the-new-architecture/backward-compatibility-fabric-components",permalink:"/docs/0.70/the-new-architecture/backward-compatibility-fabric-components",draft:!1,unlisted:!1,editUrl:"https://github.com/facebook/react-native-website/blob/main/website/../docs/the-new-architecture/backward-compatibility-fabric-components.md",tags:[],version:"0.70",lastUpdatedAt:1704504779,formattedLastUpdatedAt:"Jan 6, 2024",frontMatter:{id:"backward-compatibility-fabric-components",title:"Fabric Components as Legacy Native Components"},sidebar:"docs",previous:{title:"Turbo Modules as Legacy Native Modules",permalink:"/docs/0.70/the-new-architecture/backward-compatibility-turbomodules"},next:{title:"Migrating to the New Architecture",permalink:"/docs/0.70/new-architecture-intro"}},u={},m=[{value:"Configure the Fabric Native Component Dependencies",id:"configure-the-fabric-native-component-dependencies",level:2},{value:"iOS",id:"dependencies-ios",level:3},{value:"Android",id:"android",level:3},{value:"Update the codebase",id:"update-the-codebase",level:2},{value:"iOS",id:"ios",level:3},{value:"Android",id:"android-1",level:3},{value:"Unify the JavaScript specs",id:"unify-the-javascript-specs",level:2}];function f(e){const n=Object.assign({admonition:"admonition",p:"p",a:"a",ol:"ol",li:"li",strong:"strong",ul:"ul",h2:"h2",h3:"h3",code:"code",pre:"pre"},(0,i.ah)(),e.components);return(0,a.jsxs)(a.Fragment,{children:[(0,a.jsx)(l.ZP,{}),"\n",(0,a.jsxs)(n.admonition,{type:"info",children:[(0,a.jsxs)(n.p,{children:["Creating a backward compatible Fabric Native Component requires the knowledge of how to create a Legacy Native Component. To recall these concepts, have a look at this ",(0,a.jsx)(n.a,{href:"pillars-fabric-components",children:"guide"}),"."]}),(0,a.jsxs)(n.p,{children:["Fabric Native Components only work when the New Architecture is properly set up. If you already have a library that you want to migrate to the New Architecture, have a look at the ",(0,a.jsx)(n.a,{href:"../new-architecture-intro",children:"migration guide"})," as well."]})]}),"\n",(0,a.jsx)(n.p,{children:"Creating a backward compatible Fabric Native Component lets your users continue to leverage your library independently from the architecture they use. The creation of such a component requires a few steps:"}),"\n",(0,a.jsxs)(n.ol,{children:["\n",(0,a.jsx)(n.li,{children:"Configure the library so that dependencies are prepared set up properly for both the Old and the New Architecture."}),"\n",(0,a.jsx)(n.li,{children:"Update the codebase so that the New Architecture types are not compiled when not available."}),"\n",(0,a.jsx)(n.li,{children:"Uniform the JavaScript API so that your user code won't need changes."}),"\n"]}),"\n",(0,a.jsxs)(n.admonition,{type:"info",children:[(0,a.jsxs)(n.p,{children:["For the sake of this guide we're going to use the following ",(0,a.jsx)(n.strong,{children:"terminology"}),":"]}),(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Legacy Native Components"})," - To refer to Components which are running on the old React Native architecture."]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Fabric Native Components"})," - To refer to Components which have been adapted to work well with the New Native Renderer, Fabric. For brevity you might find them referred as ",(0,a.jsx)(n.strong,{children:"Fabric Components"}),"."]}),"\n"]})]}),"\n",(0,a.jsx)(c.ZP,{}),"\n",(0,a.jsx)(n.p,{children:"While the last step is the same for all the platforms, the first two steps are different for iOS and Android."}),"\n",(0,a.jsx)(n.h2,{id:"configure-the-fabric-native-component-dependencies",children:"Configure the Fabric Native Component Dependencies"}),"\n",(0,a.jsx)(n.h3,{id:"dependencies-ios",children:"iOS"}),"\n",(0,a.jsxs)(n.p,{children:["The Apple platform installs Fabric Native Components using ",(0,a.jsx)(n.a,{href:"https://cocoapods.org",children:"CocoaPods"})," as a dependency manager."]}),"\n",(0,a.jsxs)(n.p,{children:["Every Fabric Native Component defines a ",(0,a.jsx)(n.code,{children:"podspec"})," that looks like this:"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-ruby",children:'require "json"\n\npackage = JSON.parse(File.read(File.join(__dir__, "package.json")))\n\nfolly_compiler_flags = \'-DFOLLY_NO_CONFIG -DFOLLY_MOBILE=1 -DFOLLY_USE_LIBCPP=1 -Wno-comma -Wno-shorten-64-to-32\'\n\nPod::Spec.new do |s|\n  # Default fields for a valid podspec\n  s.name            = "<FC Name>"\n  s.version         = package["version"]\n  s.summary         = package["description"]\n  s.description     = package["description"]\n  s.homepage        = package["homepage"]\n  s.license         = package["license"]\n  s.platforms       = { :ios => "11.0" }\n  s.author          = package["author"]\n  s.source          = { :git => package["repository"], :tag => "#{s.version}" }\n\n  s.source_files    = "ios/**/*.{h,m,mm,swift}"\n  # React Native Core dependency\n  s.dependency "React-Core"\n\n  #\xa0The following lines are required by the New Architecture.\n  s.compiler_flags = folly_compiler_flags + " -DRCT_NEW_ARCH_ENABLED=1"\n  s.pod_target_xcconfig    = {\n      "HEADER_SEARCH_PATHS" => "\\"$(PODS_ROOT)/boost\\"",\n      "OTHER_CPLUSPLUSFLAGS" => "-DFOLLY_NO_CONFIG -DFOLLY_MOBILE=1 -DFOLLY_USE_LIBCPP=1",\n      "CLANG_CXX_LANGUAGE_STANDARD" => "c++17"\n  }\n\n  s.dependency "React-RCTFabric"\n  s.dependency "React-Codegen"\n  s.dependency "RCT-Folly"\n  s.dependency "RCTRequired"\n  s.dependency "RCTTypeSafety"\n  s.dependency "ReactCommon/turbomodule/core"\nend\n'})}),"\n",(0,a.jsxs)(n.p,{children:["The ",(0,a.jsx)(n.strong,{children:"goal"})," is to avoid installing the dependencies when the app is prepared for the Old Architecture."]}),"\n",(0,a.jsx)(n.p,{children:"When we want to install the dependencies, we use the following commands depending on the architecture:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-sh",children:"# For the Old Architecture, we use:\npod install\n\n# For the New Architecture, we use:\nRCT_NEW_ARCH_ENABLED=1 pod install\n"})}),"\n",(0,a.jsxs)(n.p,{children:["Therefore, we can leverage this environment variable in the ",(0,a.jsx)(n.code,{children:"podspec"})," to exclude the settings and the dependencies that are related to the New Architecture:"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-diff",children:"+ if ENV['RCT_NEW_ARCH_ENABLED'] == '1' then\n    #\xa0The following lines are required by the New Architecture.\n    s.compiler_flags = folly_compiler_flags + \" -DRCT_NEW_ARCH_ENABLED=1\"\n    # ... other dependencies ...\n    s.dependency \"ReactCommon/turbomodule/core\"\n+ end\nend\n"})}),"\n",(0,a.jsxs)(n.p,{children:["This ",(0,a.jsx)(n.code,{children:"if"})," guard prevents the dependencies from being installed when the environment variable is not set."]}),"\n",(0,a.jsx)(n.h3,{id:"android",children:"Android"}),"\n",(0,a.jsxs)(n.p,{children:["To create a Native Component that can work with both architectures, you need to configure Gradle to choose which files need to be compiled depending on the chosen architecture. This can be achieved by using ",(0,a.jsx)(n.strong,{children:"different source sets"})," in the Gradle configuration."]}),"\n",(0,a.jsx)(n.admonition,{type:"note",children:(0,a.jsx)(n.p,{children:"Please note that this is currently the suggested approach. While it might lead to some code duplication, it will ensure the maximum compatibility with both architectures. You will see how to reduce the duplication in the next section."})}),"\n",(0,a.jsxs)(n.p,{children:["To configure the Fabric Native Component so that it picks the proper sourceset, you have to update the ",(0,a.jsx)(n.code,{children:"build.gradle"})," file in the following way:"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-diff",metastring:'title="build.gradle"',children:"+// Add this function in case you don't have it already\n+ def isNewArchitectureEnabled() {\n+    return project.hasProperty(\"newArchEnabled\") && project.newArchEnabled == \"true\"\n+}\n// ... other parts of the build file\ndefaultConfig {\n        minSdkVersion safeExtGet('minSdkVersion', 21)\n        targetSdkVersion safeExtGet('targetSdkVersion', 31)\n+        buildConfigField(\"boolean\", \"IS_NEW_ARCHITECTURE_ENABLED\", isNewArchitectureEnabled().toString())\n+    }\n+\n+    sourceSets {\n+        main {\n+            if (isNewArchitectureEnabled()) {\n+                java.srcDirs += ['src/newarch']\n+            } else {\n+                java.srcDirs += ['src/oldarch']\n+            }\n+        }\n    }\n}\n"})}),"\n",(0,a.jsx)(n.p,{children:"This changes do three main things:"}),"\n",(0,a.jsxs)(n.ol,{children:["\n",(0,a.jsx)(n.li,{children:"The first lines define a function that returns whether the New Architecture is enabled or not."}),"\n",(0,a.jsxs)(n.li,{children:["The ",(0,a.jsx)(n.code,{children:"buildConfigField"})," line defines a build configuration boolean field called ",(0,a.jsx)(n.code,{children:"IS_NEW_ARCHITECTURE_ENABLED"}),", and initialize it using the function declared in the first step. This allows you to check at runtime if a user has specified the ",(0,a.jsx)(n.code,{children:"newArchEnabled"})," property or not."]}),"\n",(0,a.jsx)(n.li,{children:"The last lines leverage the function declared in step one to decide which source sets we need to build, depending on the choosen architecture."}),"\n"]}),"\n",(0,a.jsx)(n.h2,{id:"update-the-codebase",children:"Update the codebase"}),"\n",(0,a.jsx)(n.h3,{id:"ios",children:"iOS"}),"\n",(0,a.jsx)(n.p,{children:"The second step is to instruct Xcode to avoid compiling all the lines using the New Architecture types and files when we are building an app with the Old Architecture."}),"\n",(0,a.jsxs)(n.p,{children:["A Fabric Native Component requires an header file and an implementation file to add the actual ",(0,a.jsx)(n.code,{children:"View"})," to the module."]}),"\n",(0,a.jsxs)(n.p,{children:["For example, the ",(0,a.jsx)(n.code,{children:"RNMyComponentView.h"})," header file could look like this:"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-objectivec",metastring:"title='RNMyComponentView.h'",children:"#import <React/RCTViewComponentView.h>\n#import <UIKit/UIKit.h>\n\n#ifndef NativeComponentExampleComponentView_h\n#define NativeComponentExampleComponentView_h\n\nNS_ASSUME_NONNULL_BEGIN\n\n@interface RNMyComponentView : RCTViewComponentView\n@end\n\nNS_ASSUME_NONNULL_END\n\n#endif /* NativeComponentExampleComponentView_h */\n"})}),"\n",(0,a.jsxs)(n.p,{children:["The implementation ",(0,a.jsx)(n.code,{children:"RNMyComponentView.mm"})," file, instead, could look like this:"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-objectivec",metastring:"title='RNMyComponentView.mm'",children:'#import "RNMyComponentView.h"\n\n// <react/renderer imports>\n\n#import "RCTFabricComponentsPlugins.h"\n\nusing namespace facebook::react;\n\n@interface RNMyComponentView () <RCTMyComponentViewViewProtocol>\n\n@end\n\n@implementation RNMyComponentView {\n    UIView * _view;\n}\n\n+ (ComponentDescriptorProvider)componentDescriptorProvider\n{\n    // ... return the descriptor ...\n}\n\n- (instancetype)initWithFrame:(CGRect)frame\n{\n  // ... initialize the object ...\n}\n\n- (void)updateProps:(Props::Shared const &)props oldProps:(Props::Shared const &)oldProps\n{\n  // ... set up the props ...\n\n  [super updateProps:props oldProps:oldProps];\n}\n\nClass<RCTComponentViewProtocol> MyComponentViewCls(void)\n{\n  return RNMyComponentView.class;\n}\n\n@end\n'})}),"\n",(0,a.jsxs)(n.p,{children:["To make sure that Xcode skips these files, we can wrap ",(0,a.jsx)(n.strong,{children:"both"})," of them in some ",(0,a.jsx)(n.code,{children:"#ifdef RCT_NEW_ARCH_ENABLED"})," compilation pragma. For example, the header file could change as follows:"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-diff",children:"+ #ifdef RCT_NEW_ARCH_ENABLED\n#import <React/RCTViewComponentView.h>\n#import <UIKit/UIKit.h>\n\n// ... rest of the header file ...\n\n#endif /* NativeComponentExampleComponentView_h */\n+ #endif\n"})}),"\n",(0,a.jsx)(n.p,{children:"The same two lines should be added in the implementation file, as first and last lines."}),"\n",(0,a.jsxs)(n.p,{children:["The above snippet uses the same ",(0,a.jsx)(n.code,{children:"RCT_NEW_ARCH_ENABLED"})," flag used in the previous ",(0,a.jsx)(n.a,{href:"#dependencies-ios",children:"section"}),". When this flag is not set, Xcode skips the lines within the ",(0,a.jsx)(n.code,{children:"#ifdef"})," during compilation and it does not include them into the compiled binary. The compiled binary will have a the ",(0,a.jsx)(n.code,{children:"RNMyComponentView.o"})," object but it will be an empty object."]}),"\n",(0,a.jsx)(n.h3,{id:"android-1",children:"Android"}),"\n",(0,a.jsx)(n.p,{children:"As we can't use conditional compilation blocks on Android, we will define two different source sets. This will allow to create a backward compatible TurboModule with the proper source that is loaded and compiled depending on the used architecture."}),"\n",(0,a.jsx)(n.p,{children:"Therefore, you have to:"}),"\n",(0,a.jsxs)(n.ol,{children:["\n",(0,a.jsxs)(n.li,{children:["Create a Legacy Native Component in the ",(0,a.jsx)(n.code,{children:"src/oldarch"})," path. See ",(0,a.jsx)(n.a,{href:"../native-components-android",children:"this guide"})," to learn how to create a Legacy Native Component."]}),"\n",(0,a.jsxs)(n.li,{children:["Create a Fabric Native Component in the ",(0,a.jsx)(n.code,{children:"src/newarch"})," path. See ",(0,a.jsx)(n.a,{href:"pillars-fabric-components",children:"this guide"})," to learn how to create a Fabric Native Component."]}),"\n"]}),"\n",(0,a.jsx)(n.p,{children:"and then instruct Gradle to decide which implementation to pick."}),"\n",(0,a.jsx)(n.p,{children:"Some files can be shared between a Legacy and a Fabric Component: these should be created or moved into a folder that is loaded by both the architectures. These files are:"}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsxs)(n.li,{children:["the ",(0,a.jsx)(n.code,{children:"<MyComponentView>.java"})," that instantiate and configure the Android View for both the components."]}),"\n",(0,a.jsxs)(n.li,{children:["the ",(0,a.jsx)(n.code,{children:"<MyComponentView>ManagerImpl.java"})," file where which contains the logic of the ViewManager that can be shared between the Legacy and the Fabric Component."]}),"\n",(0,a.jsxs)(n.li,{children:["the ",(0,a.jsx)(n.code,{children:"<MyComponentView>Package.java"})," file used to load the component."]}),"\n"]}),"\n",(0,a.jsx)(n.p,{children:"The final folder structure looks like this:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-sh",children:"my-component\n\u251c\u2500\u2500 android\n\u2502   \u251c\u2500\u2500 build.gradle\n\u2502   \u2514\u2500\u2500 src\n\u2502       \u251c\u2500\u2500 main\n\u2502       \u2502   \u251c\u2500\u2500 AndroidManifest.xml\n\u2502       \u2502   \u2514\u2500\u2500 java\n\u2502       \u2502       \u2514\u2500\u2500 com\n\u2502       \u2502           \u2514\u2500\u2500 MyComponent\n\u2502       \u2502               \u251c\u2500\u2500 MyComponentView.java\n\u2502       \u2502               \u251c\u2500\u2500 MyComponentViewManagerImpl.java\n\u2502       \u2502               \u2514\u2500\u2500 MyComponentViewPackage.java\n\u2502       \u251c\u2500\u2500 newarch\n\u2502       \u2502   \u2514\u2500\u2500 java\n\u2502       \u2502       \u2514\u2500\u2500 com\n\u2502       \u2502           \u2514\u2500\u2500 MyComponentViewManager.java\n\u2502       \u2514\u2500\u2500 oldarch\n\u2502           \u2514\u2500\u2500 java\n\u2502               \u2514\u2500\u2500 com\n\u2502                   \u2514\u2500\u2500 MyComponentViewManager.java\n\u251c\u2500\u2500 ios\n\u251c\u2500\u2500 js\n\u2514\u2500\u2500 package.json\n"})}),"\n",(0,a.jsxs)(n.p,{children:["The code that should go in the ",(0,a.jsx)(n.code,{children:"MyComponentViewManagerImpl.java"})," and that can be shared between the Native Component and the Fabric Native Component is, for example:"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-java",metastring:'title="example of MyComponentViewManager.java"',children:'package com.MyComponent;\nimport androidx.annotation.Nullable;\nimport com.facebook.react.uimanager.ThemedReactContext;\n\npublic class MyComponentViewManagerImpl {\n\n    public static final String NAME = "MyComponent";\n\n    public static MyComponentView createViewInstance(ThemedReactContext context) {\n        return new MyComponentView(context);\n    }\n\n    public static void setFoo(MyComponentView view, String param) {\n        // implement the logic of the foo function using the view and the param passed.\n    }\n}\n'})}),"\n",(0,a.jsx)(n.p,{children:"Then, the Native Component and the Fabric Native Component can be updated using the function declared in the shared manager."}),"\n",(0,a.jsx)(n.p,{children:"For example, for a Native Component:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-java",metastring:'title="Native Component using the ViewManagerImpl"',children:'public class MyComponentViewManager extends SimpleViewManager<MyComponentView> {\n\n    ReactApplicationContext mCallerContext;\n\n    public MyComponentViewManager(ReactApplicationContext reactContext) {\n        mCallerContext = reactContext;\n    }\n\n    @Override\n    public String getName() {\n        // static NAME property from the shared implementation\n        return MyComponentViewManagerImpl.NAME;\n    }\n\n    @Override\n    public MyComponentView createViewInstance(ThemedReactContext context) {\n        // static createViewInstance function from the shared implementation\n        return MyComponentViewManagerImpl.createViewInstance(context);\n    }\n\n    @ReactProp(name = "foo")\n    public void setFoo(MyComponentView view, String param) {\n        // static custom function from the shared implementation\n        MyComponentViewManagerImpl.setFoo(view, param);\n    }\n\n}\n'})}),"\n",(0,a.jsx)(n.p,{children:"And, for a Fabric Native Component:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-java",metastring:'title="Fabric Component using the ViewManagerImpl"',children:'// Use the static NAME property from the shared implementation\n@ReactModule(name = MyComponentViewManagerImpl.NAME)\npublic class MyComponentViewManager extends SimpleViewManager<MyComponentView>\n        implements MyComponentViewManagerInterface<MyComponentView> {\n\n    private final ViewManagerDelegate<MyComponentView> mDelegate;\n\n    public MyComponentViewManager(ReactApplicationContext context) {\n        mDelegate = new MyComponentViewManagerDelegate<>(this);\n    }\n\n    @Nullable\n    @Override\n    protected ViewManagerDelegate<MyComponentView> getDelegate() {\n        return mDelegate;\n    }\n\n    @NonNull\n    @Override\n    public String getName() {\n        // static NAME property from the shared implementation\n        return MyComponentViewManagerImpl.NAME;\n    }\n\n    @NonNull\n    @Override\n    protected MyComponentView createViewInstance(@NonNull ThemedReactContext context) {\n        // static createViewInstance function from the shared implementation\n        return MyComponentViewManagerImpl.createViewInstance(context);\n    }\n\n    @Override\n    @ReactProp(name = "foo")\n    public void setFoo(MyComponentView view, @Nullable String param) {\n        // static custom function from the shared implementation\n        MyComponentViewManagerImpl.setFoo(view, param]);\n    }\n}\n'})}),"\n",(0,a.jsxs)(n.p,{children:["For a step-by-step example on how to achieve this, have a look at ",(0,a.jsx)(n.a,{href:"https://github.com/react-native-community/RNNewArchitectureLibraries/tree/feat/back-fabric-comp",children:"this repo"}),"."]}),"\n",(0,a.jsx)(n.h2,{id:"unify-the-javascript-specs",children:"Unify the JavaScript specs"}),"\n",(0,a.jsx)(c.ZP,{}),"\n",(0,a.jsx)(n.p,{children:"The last step makes sure that the JavaScript behaves transparently to chosen architecture."}),"\n",(0,a.jsxs)(n.p,{children:["For a Fabric Native Component, the source of truth is the ",(0,a.jsx)(n.code,{children:"<YourModule>NativeComponent.js"})," (or ",(0,a.jsx)(n.code,{children:".ts"}),") spec file. The app accesses the spec file like this:"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-ts",children:"import MyComponent from 'your-component/src/index';\n"})}),"\n",(0,a.jsxs)(n.p,{children:["Since ",(0,a.jsx)(n.code,{children:"codegenNativeComponent"})," is calling the ",(0,a.jsx)(n.code,{children:"requireNativeComponent"})," under the hood, we need to re-export our component, to avoid registering it multiple times."]}),"\n",(0,a.jsxs)(o.Z,{groupId:"fabric-component-backward-compatibility",queryString:!0,defaultValue:s.Z.defaultFabricComponentSpecLanguage,values:s.Z.fabricComponentSpecLanguages,children:[(0,a.jsx)(r.Z,{value:"Flow",children:(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-ts",children:"// @flow\nexport default require('./MyComponentNativeComponent').default;\n"})})}),(0,a.jsx)(r.Z,{value:"TypeScript",children:(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-ts",children:"export default require('./MyComponentNativeComponent').default;\n"})})})]})]})}const b=function(e={}){const{wrapper:n}=Object.assign({},(0,i.ah)(),e.components);return n?(0,a.jsx)(n,Object.assign({},e,{children:(0,a.jsx)(f,e)})):f(e)}},86386:(e,n,t)=>{t.d(n,{Z:()=>h});var a=t(27378),i=t(38944);const o={tabItem:"tabItem_wHwb"};var r=Object.defineProperty,s=Object.getOwnPropertySymbols,c=Object.prototype.hasOwnProperty,l=Object.prototype.propertyIsEnumerable,d=(e,n,t)=>n in e?r(e,n,{enumerable:!0,configurable:!0,writable:!0,value:t}):e[n]=t,p=(e,n)=>{for(var t in n||(n={}))c.call(n,t)&&d(e,t,n[t]);if(s)for(var t of s(n))l.call(n,t)&&d(e,t,n[t]);return e};function h({children:e,hidden:n,className:t}){return a.createElement("div",p({role:"tabpanel",className:(0,i.Z)(o.tabItem,t)},{hidden:n}),e)}},48375:(e,n,t)=>{t.d(n,{Z:()=>D});var a=t(27378),i=t(38944),o=t(12112),r=t(3620),s=t(69490),c=t(14953),l=t(27886),d=t(7106),p=Object.defineProperty,h=Object.defineProperties,u=Object.getOwnPropertyDescriptors,m=Object.getOwnPropertySymbols,f=Object.prototype.hasOwnProperty,b=Object.prototype.propertyIsEnumerable,g=(e,n,t)=>n in e?p(e,n,{enumerable:!0,configurable:!0,writable:!0,value:t}):e[n]=t,w=(e,n)=>{for(var t in n||(n={}))f.call(n,t)&&g(e,t,n[t]);if(m)for(var t of m(n))b.call(n,t)&&g(e,t,n[t]);return e},v=(e,n)=>h(e,u(n));function y(e){var n,t;return null!=(t=null==(n=a.Children.toArray(e).filter((e=>"\n"!==e)).map((e=>{if(!e||(0,a.isValidElement)(e)&&function(e){const{props:n}=e;return!!n&&"object"==typeof n&&"value"in n}(e))return e;throw new Error(`Docusaurus error: Bad <Tabs> child <${"string"==typeof e.type?e.type:e.type.name}>: all children of the <Tabs> component should be <TabItem>, and every <TabItem> should have a unique "value" prop.`)})))?void 0:n.filter(Boolean))?t:[]}function j(e){const{values:n,children:t}=e;return(0,a.useMemo)((()=>{const e=null!=n?n:function(e){return y(e).map((({props:{value:e,label:n,attributes:t,default:a}})=>({value:e,label:n,attributes:t,default:a})))}(t);return function(e){const n=(0,l.l)(e,((e,n)=>e.value===n.value));if(n.length>0)throw new Error(`Docusaurus error: Duplicate values "${n.map((e=>e.value)).join(", ")}" found in <Tabs>. Every value needs to be unique.`)}(e),e}),[n,t])}function x({value:e,tabValues:n}){return n.some((n=>n.value===e))}function C({queryString:e=!1,groupId:n}){const t=(0,r.k6)(),i=function({queryString:e=!1,groupId:n}){if("string"==typeof e)return e;if(!1===e)return null;if(!0===e&&!n)throw new Error('Docusaurus error: The <Tabs> component groupId prop is required if queryString=true, because this value is used as the search param name. You can also provide an explicit value such as queryString="my-search-param".');return null!=n?n:null}({queryString:e,groupId:n});return[(0,c._X)(i),(0,a.useCallback)((e=>{if(!i)return;const n=new URLSearchParams(t.location.search);n.set(i,e),t.replace(v(w({},t.location),{search:n.toString()}))}),[i,t])]}function N(e){const{defaultValue:n,queryString:t=!1,groupId:i}=e,o=j(e),[r,c]=(0,a.useState)((()=>function({defaultValue:e,tabValues:n}){var t;if(0===n.length)throw new Error("Docusaurus error: the <Tabs> component requires at least one <TabItem> children component");if(e){if(!x({value:e,tabValues:n}))throw new Error(`Docusaurus error: The <Tabs> has a defaultValue "${e}" but none of its children has the corresponding value. Available values are: ${n.map((e=>e.value)).join(", ")}. If you intend to show no default tab, use defaultValue={null} instead.`);return e}const a=null!=(t=n.find((e=>e.default)))?t:n[0];if(!a)throw new Error("Unexpected error: 0 tabValues");return a.value}({defaultValue:n,tabValues:o}))),[l,p]=C({queryString:t,groupId:i}),[h,u]=function({groupId:e}){const n=function(e){return e?`docusaurus.tab.${e}`:null}(e),[t,i]=(0,d.Nk)(n);return[t,(0,a.useCallback)((e=>{n&&i.set(e)}),[n,i])]}({groupId:i}),m=(()=>{const e=null!=l?l:h;return x({value:e,tabValues:o})?e:null})();(0,s.Z)((()=>{m&&c(m)}),[m]);return{selectedValue:r,selectValue:(0,a.useCallback)((e=>{if(!x({value:e,tabValues:o}))throw new Error(`Can't select invalid tab value=${e}`);c(e),p(e),u(e)}),[p,u,o]),tabValues:o}}var M=t(14185);const V={tabList:"tabList_J5MA",tabItem:"tabItem_l0OV"};var k=Object.defineProperty,E=Object.defineProperties,_=Object.getOwnPropertyDescriptors,A=Object.getOwnPropertySymbols,T=Object.prototype.hasOwnProperty,S=Object.prototype.propertyIsEnumerable,O=(e,n,t)=>n in e?k(e,n,{enumerable:!0,configurable:!0,writable:!0,value:t}):e[n]=t,R=(e,n)=>{for(var t in n||(n={}))T.call(n,t)&&O(e,t,n[t]);if(A)for(var t of A(n))S.call(n,t)&&O(e,t,n[t]);return e},F=(e,n)=>E(e,_(n));function I({className:e,block:n,selectedValue:t,selectValue:r,tabValues:s}){const c=[],{blockElementScrollPositionUntilNextRender:l}=(0,o.o5)(),d=e=>{const n=e.currentTarget,a=c.indexOf(n),i=s[a].value;i!==t&&(l(n),r(i))},p=e=>{var n,t;let a=null;switch(e.key){case"Enter":d(e);break;case"ArrowRight":{const t=c.indexOf(e.currentTarget)+1;a=null!=(n=c[t])?n:c[0];break}case"ArrowLeft":{const n=c.indexOf(e.currentTarget)-1;a=null!=(t=c[n])?t:c[c.length-1];break}}null==a||a.focus()};return a.createElement("ul",{role:"tablist","aria-orientation":"horizontal",className:(0,i.Z)("tabs",{"tabs--block":n},e)},s.map((({value:e,label:n,attributes:o})=>a.createElement("li",F(R({role:"tab",tabIndex:t===e?0:-1,"aria-selected":t===e,key:e,ref:e=>c.push(e),onKeyDown:p,onClick:d},o),{className:(0,i.Z)("tabs__item",V.tabItem,null==o?void 0:o.className,{"tabs__item--active":t===e})}),null!=n?n:e))))}function L({lazy:e,children:n,selectedValue:t}){const i=(Array.isArray(n)?n:[n]).filter(Boolean);if(e){const e=i.find((e=>e.props.value===t));return e?(0,a.cloneElement)(e,{className:"margin-top--md"}):null}return a.createElement("div",{className:"margin-top--md"},i.map(((e,n)=>(0,a.cloneElement)(e,{key:n,hidden:e.props.value!==t}))))}function P(e){const n=N(e);return a.createElement("div",{className:(0,i.Z)("tabs-container",V.tabList)},a.createElement(I,R(R({},e),n)),a.createElement(L,R(R({},e),n)))}function D(e){const n=(0,M.Z)();return a.createElement(P,R({key:String(n)},e),y(e.children))}},11674:(e,n,t)=>{t.d(n,{Z:()=>r});var a=t(63445);const i=!!a.Z.canUseDOM&&navigator.platform.startsWith("Mac"),o=!!a.Z.canUseDOM&&navigator.platform.startsWith("Win"),r={defaultGuide:"quickstart",defaultJsDebugger:"flipper",defaultOs:i?"macos":o?"windows":"linux",defaultPackageManager:"npm",defaultPlatform:i?"ios":"android",defaultSyntax:"functional",defaultAndroidLanguage:"java",defaultJavaScriptSpecLanguages:"typescript",getDevNotesTabs:(e=["android","ios","web","windows"])=>[e.includes("android")?{label:"Android",value:"android"}:void 0,e.includes("ios")?{label:"iOS",value:"ios"}:void 0,e.includes("web")?{label:"Web",value:"web"}:void 0,e.includes("windows")?{label:"Windows",value:"windows"}:void 0].filter(Boolean),guides:[{label:"Expo Go Quickstart",value:"quickstart"},{label:"React Native CLI Quickstart",value:"native"}],oses:[{label:"macOS",value:"macos"},{label:"Windows",value:"windows"},{label:"Linux",value:"linux"}],packageManagers:[{label:"npm",value:"npm"},{label:"Yarn",value:"yarn"}],platforms:[{label:"Android",value:"android"},{label:"iOS",value:"ios"}],syntax:[{label:"Function Component",value:"functional"},{label:"Class Component",value:"classical"}],androidLanguages:[{label:"Java",value:"java"},{label:"Kotlin",value:"kotlin"}],javaScriptSpecLanguages:[{label:"TypeScript",value:"typescript"},{label:"Flow",value:"flow"}],jsDebuggers:[{label:"Hermes Debugger / Expo",value:"hermes"},{label:"Flipper",value:"flipper"},{label:"New Debugger (Experimental)",value:"new-debugger"}],snackLanguages:[{label:"TypeScript",value:"typescript"},{label:"JavaScript",value:"javascript"}],defaultSnackLanguage:"typescript"}},71426:(e,n,t)=>{var a=t(27378),i=Symbol.for("react.element"),o=Symbol.for("react.fragment"),r=Object.prototype.hasOwnProperty,s=a.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.ReactCurrentOwner,c={key:!0,ref:!0,__self:!0,__source:!0};function l(e,n,t){var a,o={},l=null,d=null;for(a in void 0!==t&&(l=""+t),void 0!==n.key&&(l=""+n.key),void 0!==n.ref&&(d=n.ref),n)r.call(n,a)&&!c.hasOwnProperty(a)&&(o[a]=n[a]);if(e&&e.defaultProps)for(a in n=e.defaultProps)void 0===o[a]&&(o[a]=n[a]);return{$$typeof:i,type:e,key:l,ref:d,props:o,_owner:s.current}}n.Fragment=o,n.jsx=l,n.jsxs=l},24246:(e,n,t)=>{e.exports=t(71426)},71670:(e,n,t)=>{t.d(n,{Zo:()=>s,ah:()=>o});var a=t(27378);const i=a.createContext({});function o(e){const n=a.useContext(i);return a.useMemo((()=>"function"==typeof e?e(n):{...n,...e}),[n,e])}const r={};function s({components:e,children:n,disableParentContext:t}){let s;return s=t?"function"==typeof e?e({}):e||r:o(e),a.createElement(i.Provider,{value:s},n)}}}]);